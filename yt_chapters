#! /usr/bin/env python3
# -*- coding: utf-8 -*-

# TODO: change working location to be a temp dir
# TODO: Add option for mkv

import subprocess, os, argparse, datetime, re, sys
from pathlib import Path
from yt_dlp import YoutubeDL
from handleYDL import *

USE_CLI = False
CLI_PATH = 'yt-dlp'

def get_default_download_dir():
    if os.name == 'nt':
        import winreg
        sub_key = r'SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders'
        downloads_guid = '{374DE290-123F-4565-9164-39C4925E467B}'
        with winreg.OpenKey(winreg.HKEY_CURRENT_USER, sub_key) as key:
            location = winreg.QueryValueEx(key, downloads_guid)[0]
        return Path(location)
    else:
        return Path.home() / "Downloads"

def add_chapters_to_mp4(chapter_file_path:Path, video_file_path:Path)->None:

    # Use MP4Box to mux the chapter file with the mp4
    subprocess.run(["MP4Box", "-chap", str(chapter_file_path), str(video_file_path)])

def get_chapters( chapters_str:str )->list:

    # Read the description file
    # Split into time and chapter name

    list_of_chapters = []

    # only increment chapter number on a chapter line
    # chapter lines start with timecode
    line_counter = 1
    for line in chapters_str.split('\n'):
        result = re.search(r"\(?(\d?[:]?\d+[:]\d+)\)?", line)
        try:
            # result = re.search("\(?(\d+[:]\d+[:]\d+)\)?", line)
            time_count = datetime.datetime.strptime(result.group(1), '%H:%M:%S')
        except:
            try:
                # result = re.search("\(?(\d+[:]\d+)\)?", line)
                time_count = datetime.datetime.strptime(result.group(1), '%M:%S')
            except:
                continue
        chap_name = line.replace(result.group(0),"").rstrip(' :\n')
        # Filter out characters that might be problematic for filenames
        chap_name = re.sub(r'[\\/*?:"<>|]', "", chap_name)
        chap_pos = datetime.datetime.strftime(time_count, '%H:%M:%S')
        list_of_chapters.append((str(line_counter).zfill(2), chap_pos, chap_name))
        line_counter += 1

    return list_of_chapters

def write_chapters_file(chapter_file_path:Path, chapter_list:tuple)->None:

    #open(chapter_file, 'w').close()

    # Write out the chapter file based on simple MP4 format (OGM)
    with open(chapter_file_path, 'w', encoding='utf-8') as fo:
        for current_chapter in chapter_list:
            fo.write(f'CHAPTER{current_chapter[0]}='
                    f'{current_chapter[1]}\n'
                    f'CHAPTER{current_chapter[0]}NAME='
                    f'{current_chapter[2]}\n')


def split_mp4(chapters:list, download_filename:Path, download_name:str, out_dir:Path)->None:

    # current_duration = subprocess.run(['ffprobe', '-i', download_filename,
                                       # '-show_entries', 'format=duration',
                                       # '-v', 'quiet', '-of', 'csv="p=0"'],
                                        # capture_output=True, encoding='UTF8')
    current_duration_pretext = subprocess.run(['ffprobe', '-i', str(download_filename),
                                       '-show_entries', 'format=duration',
                                       '-v', 'quiet'],
                                        capture_output=True, encoding='UTF8')
    try:
        current_duration = float(current_duration_pretext.stdout[18:-13])
    except:
        # Fallback for different ffprobe output formats
        match = re.search(r'duration=([\d.]+)', current_duration_pretext.stdout)
        if match:
            current_duration = float(match.group(1))
        else:
            print("Could not determine video duration. Skipping split.")
            return

    m, s = divmod(current_duration, 60)
    h, m = divmod(m, 60)
    current_dur = ':'.join([str(int(h)),str(int(m)),str(s)])
    for current_index, current_chapter in enumerate(chapters):
        # current_chapter will be a tuple: position, timecode, name
        next_index = current_index + 1
        start_time = current_chapter[1]
        try:
            end_time = chapters[next_index][1]
        except:
            end_time = current_dur
        
        output_name = out_dir / f'{current_chapter[0]} - {current_chapter[2]}.mp4'
        subprocess.run(["ffmpeg", "-ss", start_time, "-to", end_time,
                        "-i", str(download_filename), "-acodec", "copy",
                        "-vcodec", "copy", str(output_name)])

def get_args():
    parser = argparse.ArgumentParser(description='Download Youtube videos with chapters')

    parser.add_argument('links', metavar='N', type=str, nargs='+',
                        help='List of links to download')
    parser.add_argument('--use-cli', help="Use yt-dlp installed",
                        action="store_true")
    parser.add_argument('--cli-path', type=str, help="Define the path of the installed yt-dlp")
    parser.add_argument("--split", help="Split chapters into individual files",
                        action="store_true")
    parser.add_argument("--test", help="Download worst version to speed up testing",
                        action="store_true")
    parser.add_argument("--fix", help="Pause to allow manual correction of the description file",
                        action="store_true")
    parser.add_argument("--quality", type=str, help="Define the quality of the video (yt-dlp format selection)",
                        default="bestvideo[height<=1080]+bestaudio/best[height<=1080]")
    parser.add_argument("--outdir", type=str, help="Define the output directory",
                        default=str(get_default_download_dir()))
    
    return parser.parse_args()

if __name__ == '__main__':

    args = get_args()
    
    if args.use_cli:
        USE_CLI = True
        CLI_PATH = args.cli_path

    base_out_dir = Path(args.outdir)

    for index in range( 0, len(args.links) ):
        
        link_to_download = args.links[index]
        options = {}
        
        # Get infos first to determine title
        temp_options = {'quiet': True}
        infos = get_infos( link_to_download, temp_options, USE_CLI )
        
        download_name = infos['title']
        # Clean title for filename/folder
        download_name = re.sub(r'[\\/*?:"<>|]', "", download_name)
        
        # Create a subfolder for the video
        video_out_dir = base_out_dir / download_name
        video_out_dir.mkdir(parents=True, exist_ok=True)
        
        download_filename = video_out_dir / f'{download_name}.mp4'
        chapter_file = video_out_dir / f'{download_name}_chapter.txt'
        description = infos['description']

        if args.fix:
            input("Fix the description file to have the chapters "
                  "on their own lines in the format timecode name "
                  "and then press Enter to continue...")
        
        chapters = get_chapters( description )

        options['outtmpl'] = str(video_out_dir / '%(title)s.%(ext)s')
        options['merge_output_format'] = "mp4"
        if args.test:
            options['format'] = "worstvideo[ext=mp4]+worstaudio[ext=m4a]/mp4"
        else:
            options['format'] = args.quality
            
        download( link_to_download, options, USE_CLI )
        
        # Verify if the file was downloaded (sometimes extension varies or title is different)
        # yt-dlp might have changed the filename slightly. We search for it.
        if not download_filename.exists():
            # Try to find the file in video_out_dir that starts with download_name and ends with .mp4
            matches = list(video_out_dir.glob(f"{download_name}*.mp4"))
            if matches:
                download_filename = matches[0]
            else:
                print(f"Could not find downloaded file for {download_name}. Skipping chapters.")
                continue

        if not chapters:
            print("No chapters found")
        else:
            write_chapters_file(chapter_file_path=chapter_file, chapter_list=chapters)

            if args.split:
                split_mp4(chapters=chapters, download_filename=download_filename,
                          download_name=download_name, out_dir=video_out_dir)
            
            add_chapters_to_mp4(chapter_file_path=chapter_file,
                                  video_file_path=download_filename)

            # Clean up the text files
            if chapter_file.exists():
                os.remove(chapter_file)
